# GraphQL: Directives

## Introduction

A GraphQL schema describes directives which are used to annotate various parts of a GraphQL document as an indicator that 
they should be evaluated differently by a validator, executor, or client tool such as a code generator.
GraphQL implementations should provide the @skip and @include directives.
GraphQL implementations that support the type system definition language must provide the  @deprecated directive if 
representing deprecated portions of the schema.
Directives must only be used in the locations they are declared to belong in. In this example, a directive is defined 
which can be used to annotate a field: [facebook.github.io/graphql](https://facebook.github.io/graphql/draft/#sec-Type-System.Directives) 

Authorization is a good and common scenario in which we usually will make use of directives. We could control what
users are allowd to fetch an object (or even an attribute) from the server.

```graphql

directive @isAuthenticated on FIELD | FIELD_DEFINITION
directive @hasRole(role: String) on FIELD | FIELD_DEFINITION


```

or for clients tools as It was mentioned on the above paragraph.

```graphql
directive @deprecated(
  reason: String = "No longer supported"
) on FIELD_DEFINITION | ENUM_VALUE


type ExampleType {
  newField: String
  oldField: String @deprecated(reason: "Use `newField`.")
}

```


## Code

In the below example we will implement a directive that can be assigned to fields
This directive transform to lowercase the string attribute.

**LowercaseDirective.js** (this file will be in package directive)
```java
@Component
public class LowercaseDirective implements SchemaDirectiveWiring {

    @Override
    public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFieldDefinition> env) {
        GraphQLFieldDefinition field = env.getElement();
        DataFetcher dataFetcher = DataFetcherFactories.wrapDataFetcher(field.getDataFetcher(), (((dataFetchingEnvironment, value) -> {
            if (value instanceof String) {
                return ((String) value).toLowercase();
            }
            return value;
        })));
        return field.transform(builder -> builder.dataFetcher(dataFetcher));
    }
}

```

Once we've defined our directive we just need to register the bean.

**Application.java**
```java
@SpringBootApplication
public class Application {
    
    @Bean
    @Autowired
    public SchemaDirective lowerCaseDirective(LowercaseDirective directive) {
        return new SchemaDirective("lower", directive);
    }
}
```

## Challenges

1. Create a directive @uppercase that can be assigned to fields. This directive will transform the value of the attribute
into uppercase. The directive declaration will look lie this

```graphql
directive @uppercase on FIELD_DEFINITION
```  

2. Create a directive @multiply with an attribute factor. The directive declaration
should look like this

```graphql
directive @multiply (
    factor: Int!
) on FIELD_DEFINITION
```
And when the directive is assigned to an field its value will be multiplied by the given factor.

```graphql
input CarRequest {
    km:Int! @multiply(factor:2)
}
```