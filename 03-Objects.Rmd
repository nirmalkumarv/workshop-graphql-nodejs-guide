# GraphQL: Objects

## Introduction

The GraphQL specification includes the following default scalar types: Int, Float, String, Boolean and ID. 
While this covers most of the use cases, often you need to support custom atomic data types (e.g. Date), 
or you want a version of an existing type that does some validation. To enable this, GraphQL allows you to 
define custom scalar types. Enumerations are similar to custom scalars, but their values can only be one 
of a pre-defined list of strings. 


The way to define new scalars or enums in the schema is shown below:

```graphql
scalar MyCustomScalar

enum Direction {
  NORTH
  EAST
  SOUTH
  WEST
}

type MyType {
    myAttribute: MyCustomScalar
    direction: Direction
    ...
}

```

Fields can take arguments as input. These can be used to determine the return value (eg, filtering search results) or 
to modify the application state. These are known as **field arguments**.

If you have a look at our schema.graphql you can find an example of usage of a field argument for attribute actors 
in type Movie. 


## Code

### Resolvers


Let's imagine that we have an operation that returns a Employee type and this
type contains an attribute details of type SocialDetails whose information needs to be taken from an external API.
And this attribute won't be always required by the API consumers. Server should not
waste time on obtaining something that clients do not need.


**resolvers.js**
```js
export default {
    Person: {
        details: async ({personId}) => {
            return await getDetailsFromLinkedin(personId)
        },
    }
    
}
``` 

Now, image that SocialDetails can be taken from more than one social network
and we want to permit the consumers to decide which social network must be used. 
(It's known as field arguments)

**schema.graphql.**
```graphl
enum Source{
    Linkedin
    Facebook
}
type Person {

  details(source:Source=Linkedin):SocialDetails
}

```
Our resolver could look like this

**resolvers.js**
```js
export default {
    Person: {
        details: async ({personId},{source}) => {
            if (source === 'Linkedin'){
                return await getDetailsFromLinkedin(personId)    
            }
            return await getDetailsFromFacebook(personId)
        },
    }
    
}
``` 

### Scalars

The library **graphql** provides us with  class **GraphQLScalarType**. We just need to create a new instance an add it
as a new resolver. An example of scalar type is shown below:

**scalars.js**
```js
import {GraphQLScalarType} from 'graphql';

var OddType = new GraphQLScalarType({
  name: 'Odd',
  serialize: oddValue,
  parseValue: oddValue,
  parseLiteral(ast) {
    if (ast.kind === Kind.INT) {
      return oddValue(parseInt(ast.value, 10));
    }
    return null;
  }
});

function oddValue(value) {
  return value % 2 === 1 ? value : null;
}
```

**schema.js**
```js
export default makeExecutableSchema({
    resolvers: {
        Odd:OddType
    }

})
``` 

You can find more details [here](https://graphql.org/graphql-js/type/#graphqlscalartype)



## Challenges

1. Define an enum type Genre whose values are Drama and SciFi (add as many other as you want) and use it
for attribute genre in type Movie and  MovieRequest.
2. Define an enum Gender and use it for attribute gender in type Actor.
3. Define a scalar type Url and use it in attribute thriller of types Movie and MovieRequest.
4. Define an enum type Currency whose possible values are Euro and Dollar. Our API must permit
the API consumers to decide in which currency they want to obtain attribute budget in type Movie.
