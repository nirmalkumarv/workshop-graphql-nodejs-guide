[
["index.html", "GraphQL workshop for NodeJS developers Chapter 1 Pre-requisites", " GraphQL workshop for NodeJS developers Iván Corrales Solera ivan.corrales.solera@gmail.com v0.0.1 Chapter 1 Pre-requisites Git: Installation guide can be found here. Access to Github: Resources for the course are hosted on Github. Docker &amp; docker-compose. (docker-compose must support version:“2”). Npm installed in your computer. "],
["set-up-your-environment.html", "Chapter 2 Set up your environment 2.1 Download the project 2.2 Project structure 2.3 Running the server 2.4 Workshop Application", " Chapter 2 Set up your environment 2.1 Download the project Clone the repository git clone https://github.com/wesovilabs-workshops/workshop-graphql-nodejs.git cd workshop-graphql-nodejs 2.2 Project structure Project follows the guidelines for structuring a NodeJS project You will find the following directories: src: It contains the source code for the application resources/graphql: It contains the GraphQL schema implemented by our server. resources/docker-compose: It contains the docker-compose descriptor and the containers configuration files. resources/local: It contains default configuration file that will be used when running the server locally. 2.3 Running the server From the root directory you just need to execute make deploy or in case of you don’t have make command installed docker build -t=wesovilabs/workshop-graphql-nodejs:local .; docker-compose -f resources/docker-compose/docker-compose.yml run --rm -p9001:9001 api To verify that application was launched correctly, just open The GraphQL Playground To clean the containers you just need to run make docker-stop or docker-compose -f resources/docker-compose/docker-compose.yml down -v 2.3.1 While you’re coding The above commands launch the full environment: database and API. On the other hand, when we’re coding we could launch the database from the docker-compose and the API from our local machine. Launching database container from docker-compose make database or docker-compose -f resources/docker-compose/docker-compose.yml run --rm -p5456:5432 database Run the application from your IDE or by command line npm install; APP_CONFIG_PATH=./resources/local/config.json NODE_ENV=local npm start; 2.4 Workshop Application The application is a movie cataloging tool. The purpose of this workshop is to enrich the application with new functionality that will be required in upcoming chapters. 2.4.1 Database Workshop database model Databases will be populated with below data when postgres container is launched. directors id full_name country 1 Tim Burton USA 2 James Cameron Canada 3 Steven Spielberg USA 4 Martin Scorsese UK 5 Alfred Hitchcock USA 6 Clint Eastwood UK actors id full_name country male 1 Johnny Depp USA true 2 Winona Ryder USA false 3 Russell Crowe Australia true 4 Joaquin Phoenix USA true 5 Al Pacino USA true 6 Robert de Niro USA true movies id title release_year genre budget thriller director_id 1 Edward Scissorhands 1990 SciFi 20 https://www.yout… 1 2 Gladiator 2000 Drama 103 https://www.yout… 7 movies_actors movie_id actor_id 1 1 1 2 2 3 2 4 2.4.2 API The below operations are already implemented in our project. 2.4.2.1 Queries listDirectors:[Director!]: It returns the list of directors. listActors:[Actor!]:It returns the list of actors. listMovies:[Movie!]: It returns the list of movies. getMovie(movieId:ID!):Movie: It returns the movie with given id. 2.4.2.2 Mutations addMovie(request:MovieRequest):Movie!: It adds a new movie. addDirector(request:DirectorRequest):Director!: It adds a new director. deleteDirector(“Identifier of the director” direction:ID!):[Director!]: It deletes the director with the given id. 2.4.2.3 Subscriptions listenDirectorMovies(directorId:ID!):Movie!: It opens a communication with the server and is notified when a new movie is created for the passed directorId in the request. 2.4.3 GraphQL schema The graphql schema for our application looks like this: schema { # The query root of Workshop GraphQL interface. query: Query # The root query for implementing GraphQL mutations. mutation: Mutation # The root query for implementing GraphQL subscriptions. subscription: Subscription } &quot;&quot;&quot;Available queries for Workshop API&quot;&quot;&quot; type Query { &quot;&quot;&quot;It returns the list of directors.&quot;&quot;&quot; listDirectors:[Director!] &quot;&quot;&quot;It returns the list of actors.&quot;&quot;&quot; listActors:[Actor!] &quot;&quot;&quot;It returns the list of movies.&quot;&quot;&quot; listMovies:[Movie!] &quot;&quot;&quot;It returns the movie with the fiven id&quot;&quot;&quot; getMovie(&quot;Movie identifier&quot; movieId:ID!):Movie } &quot;&quot;&quot;Available mutations for Workshop API&quot;&quot;&quot; type Mutation { &quot;&quot;&quot;I adds a new movie&quot;&quot;&quot; addMovie(request:MovieRequest):Movie! &quot;&quot;&quot;I adds a new actor&quot;&quot;&quot; addDirector(request:DirectorRequest):Director! &quot;&quot;&quot;I deletes the director with the fiven identifier&quot;&quot;&quot; deleteDirector(&quot;Identifier of the director&quot; directorId:ID!):[Director!] } &quot;&quot;&quot;Available subscriptions for Workshop API&quot;&quot;&quot; type Subscription { &quot;&quot;&quot;It returns the movies for a given director&quot;&quot;&quot; listenDirectorMovies(directorId:ID!):Movie! } &quot;&quot;&quot;Request info for creating a movie&quot;&quot;&quot; input MovieRequest { &quot;Name of the movie&quot; title: String! &quot;Year when the movie was released&quot; year: Int &quot;Genre for the movie, supported values should be: SciFi, Drama, Comedy or Action&quot; genre: String &quot;Budget for the movie, the value is provided in Euro&quot; budget: Float! &quot;URL in which we can watch the thriller of this movie&quot; thriller: String &quot;Identifier of director&quot; directorId: ID! } &quot;&quot;&quot;Movie details&quot;&quot;&quot; type Movie { &quot;Unique identifier for each movie&quot; id: ID! &quot;Name of the movie&quot; title: String! &quot;Year when the movie was released&quot; year: Int &quot;Genre for the movie, supported values should be: SciFi, Drama, Comedy or Action&quot; genre: String &quot;Budget for the movie, the value is provided in Euro&quot; budget: Float! &quot;URL in which we can watch the thriller of this movie&quot; thriller: String &quot;The director details of the movie&quot; director: Director! &quot;List of actors for the movie&quot; actors(&quot;Total of returned actors&quot; total:Int=1): [Actor!] } &quot;&quot;&quot;Director details&quot;&quot;&quot; type Director{ &quot;Unique identifier for each director&quot; id: ID! &quot;Full name of the director&quot; fullName: String! &quot;Country in which the director was born&quot; country: String } &quot;&quot;&quot;Director creation request&quot;&quot;&quot; input DirectorRequest{ &quot;Full name of the director&quot; fullName: String! &quot;Country in which the director was born&quot; country: String } &quot;&quot;&quot;Actor details&quot;&quot;&quot; type Actor { &quot;Unique identifier for each actor&quot; id: ID! &quot;Full name of the actor&quot; fullName: String! &quot;Country in which the actor was born&quot; country: String &quot;Gender of actor: Supported values are male or female&quot; gender: String } "],
["the-graphql-playground.html", "Chapter 3 The GraphQL Playground 3.1 Introduction 3.2 GraphQL syntax 3.3 Challenges", " Chapter 3 The GraphQL Playground 3.1 Introduction Once the server is up and ready we can interact with our API by making use of the GraphQL Playground. Just open ohttp://localhost:9001/graphql in your browser. GraphQL playground Queries are written on the left side and the response of these are displayed on the right one. To check the API documentation we just need to click on the green button on the right (SCHEMA) and a handy menu will be shown. 3.2 GraphQL syntax GraphQL operations are: queries, mutations and subscriptions. We can run only one operation per request. On the other hand we can send more than a query or more than a mutation at time. Queries with alias Mutations Subscriptions 3.3 Challenges Write a query that returns the below details (getMovie) for movie with id 1. Edward Scissorhands How many actors are returned from the server? Are the returned fields the same ones that appear in the picture? Create a new director (addDirector) Subscript to the movies for the created director in the previous step. (listenDirectorMovies) Open another tab in your GraphQL Playground and add a new movie in which the director is the one that you just created. (addMovie). Verify that new movie has been notified to the subscription that we launched in step 3. "],
["graphql-objects.html", "Chapter 4 GraphQL: Objects 4.1 Introduction 4.2 Code 4.3 Challenges", " Chapter 4 GraphQL: Objects 4.1 Introduction The GraphQL specification includes the following default scalar types: Int, Float, String, Boolean and ID. While this covers most of the use cases, often you need to support custom atomic data types (e.g. Date), or you want a version of an existing type that does some validation. To enable this, GraphQL allows you to define custom scalar types. Enumerations are similar to custom scalars, but their values can only be one of a pre-defined list of strings. The way to define new scalars or enums in the schema is shown below: scalar MyCustomScalar enum Direction { NORTH EAST SOUTH WEST } type MyType { myAttribute: MyCustomScalar direction: Direction ... } Fields can take arguments as input. These can be used to determine the return value (eg, filtering search results) or to modify the application state. These are known as field arguments. If you have a look at our schema.graphql you can find an example of usage of a field argument for attribute actors in type Movie. 4.2 Code 4.2.1 Resolvers Let’s imagine that we have an operation that returns a Employee type and this type contains an attribute details of type SocialDetails whose information needs to be taken from an external API. And this attribute won’t be always required by the API consumers. Server should not waste time on obtaining something that clients do not need. resolvers.js export default { Person: { details: async ({personId}) =&gt; { return await getDetailsFromLinkedin(personId) }, } } Now, image that SocialDetails can be taken from more than one social network and we want to permit the consumers to decide which social network must be used. (It’s known as field arguments) schema.graphql. enum Source{ Linkedin Facebook } type Person { details(source:Source=Linkedin):SocialDetails } Our resolver could look like this resolvers.js export default { Person: { details: async ({personId},{source}) =&gt; { if (source === &#39;Linkedin&#39;){ return await getDetailsFromLinkedin(personId) } return await getDetailsFromFacebook(personId) }, } } 4.2.2 Scalars The library graphql provides us with class GraphQLScalarType. We just need to create a new instance an add it as a new resolver. An example of scalar type is shown below: scalars.js import {GraphQLScalarType} from &#39;graphql&#39;; var OddType = new GraphQLScalarType({ name: &#39;Odd&#39;, serialize: oddValue, parseValue: oddValue, parseLiteral(ast) { if (ast.kind === Kind.INT) { return oddValue(parseInt(ast.value, 10)); } return null; } }); function oddValue(value) { return value % 2 === 1 ? value : null; } schema.js export default makeExecutableSchema({ resolvers: { Odd:OddType } }) You can find more details here 4.3 Challenges Define an enum type Genre whose values are Drama and SciFi (add as many other as you want) and use it for attribute genre in type Movie and MovieRequest. Define an enum Gender and use it for attribute gender in type Actor. Define a scalar type Url and use it in attribute thriller of types Movie and MovieRequest. Define an enum type Currency whose possible values are Euro and Dollar. Our API must permit the API consumers to decide in which currency they want to obtain attribute budget in type Movie. "],
["graphql-operations.html", "Chapter 5 GraphQL: Operations 5.1 Introduction 5.2 Code 5.3 Challenges", " Chapter 5 GraphQL: Operations 5.1 Introduction GraphQL provides us 3 different operations: Queries: Operation to retrieve data from the server. Mutations: CUD operations: Create, Update and Delete. Subscriptions: Create and maintain real time connection to the server. This enables the client to get immediate information about related events. Basically, a client subscribes to an event in the server, and whenever that event ocurrs, the server sends data to the client. In our workshop.graphql we will find already implemented operations. 5.2 Code Actually there’s not difference between implement a query or a mutation. We will just implament a function that can retrieve 4 arguments: parent: The result of the previous resolver call. args: The arguments of the resolver’s field. context: A custom object each resolver can read from/write to. info: It contains the query AST and more execution information. queries.js export const myQuery = (parentValue, args, ctx,info) =&gt; { return { } }; mutations.js export const myMutation = (parentValue, args, ctx, info) =&gt; { return { } }; Subscriptions looks a little bit different because we need to register to an event. subscriptions.js export const listenChangesInTeam = { subscribe: ( (_, {teamId}) =&gt; { return pubsub.asyncIterator(`teams.${teamId}`); } ), resolve: (payload, args, context, info) =&gt; { return payload; } } 5.3 Challenges Implement operations addActor and deleteActor. Implement operation rateMovie that retrieves a new Input type MovieRateRequest. MovieRateRequest contains the movieID, the user email and the score. The operation will persist data into table movies_rates and will return the Movie. Modify type Movie and add a new attribute rate whose value is the average score for all the given rates. Modify operation addMovie. Add a new attribute actorsId (array with the id’s of the actors). Define a new query getMovieRate that retrieves an argument movieId and the output type is MovieRate. The output must look like this: { &quot;rate&quot;: &quot;7&quot;, &quot;rates&quot;: [ { &quot;email&quot;: &quot;john.doe@mail.com&quot;, &quot;score&quot;: 8 }, { &quot;email&quot;: &quot;john.doe@mail.com&quot;, &quot;score&quot;: 6 }, ] } Create a new subscription listenRates. This operation retrieves an argument movieId and It displays the new rates for the given movieId. "],
["graphql-interfaces-and-unions.html", "Chapter 6 GraphQL: Interfaces and Unions 6.1 Introduction 6.2 Fragments 6.3 Code 6.4 Challenges", " Chapter 6 GraphQL: Interfaces and Unions 6.1 Introduction An interface exposes a certain set of fields that a type must include to implement the interface. schema.graphql interface Restaurant { id:ID! name: String! } type Indian implements Restaurant{ id:ID! name: String! brewedBeer:Boolean! } type Burger implements Restaurant{ id:ID! name: String! vegetarianOptions: Boolean! } type Query{ listRestaurants: [Restaurant!] } Unions are identical to interfaces, except that they don’t define a common set of fields. Unions are generally preferred over interfaces when the possible types do not share a logical hierarchy. union Item = Food | Electronic | Customer type Electronic { size: Float weight: Float } type Food { family: String } type Customer { fullName: String zip: String } type Query{ listItems: [Item!] } 6.2 Fragments Fragments are powerful technique when we are consuming a query that returns an Interface or an Union. They are used to define what attributes we want to obtain from the server depending on the type of the concrete element. query { listRestaurants:{ id name ... on Indian { brewedBeer } ... on Burger { vegetarianOptions } __typename } } 6.3 Code To implement a new operation with interfaces or unions is easy. We just need to do it as we did in the previous chapter GraphQL: Operations On the other hand, we need to define new resolvers to make the server understand which kind of inherited type it must return. Below we can find a real example: resolvers.js export default { Url: Url, Query:{ }, Mutation: { }, Restaurant: { __resolveType(restaurant, context, info){ if(restaurant.brewedBeer){ return &#39;Indian&#39;; } return &#39;Burger&#39; }, } ... } 6.4 Challenges Define an interface Person with commons attributes for Actor and Director. Add a new query listPeople that returns a list of people ([Person!]). Define an union named Item that could be a Movie or an Actor. Add an operations listItems that return the full list of Items. [Item!] "],
["graphql-directives.html", "Chapter 7 GraphQL: Directives 7.1 Introduction 7.2 Code 7.3 Challenges", " Chapter 7 GraphQL: Directives 7.1 Introduction A GraphQL schema describes directives which are used to annotate various parts of a GraphQL document as an indicator that they should be evaluated differently by a validator, executor, or client tool such as a code generator. GraphQL implementations should provide the @skip and @include directives. GraphQL implementations that support the type system definition language must provide the @deprecated directive if representing deprecated portions of the schema. Directives must only be used in the locations they are declared to belong in. In this example, a directive is defined which can be used to annotate a field: facebook.github.io/graphql Authorization is a good and common scenario in which we usually will make use of directives. We could control what users are allowd to fetch an object (or even an attribute) from the server. directive @isAuthenticated on FIELD | FIELD_DEFINITION directive @hasRole(role: String) on FIELD | FIELD_DEFINITION or for clients tools as It was mentioned on the above paragraph. directive @deprecated( reason: String = &quot;No longer supported&quot; ) on FIELD_DEFINITION | ENUM_VALUE type ExampleType { newField: String oldField: String @deprecated(reason: &quot;Use `newField`.&quot;) } 7.2 Code From my point of view, this could be the challenging part when implementinga GraphQL API. Have a look at apollographql.com to understand how we can implement our own directives. Below a very basic example of directive. directives.js import { SchemaDirectiveVisitor } from &quot;graphql-tools&quot;; class DeprecatedDirective extends SchemaDirectiveVisitor { visitFieldDefinition(field) { field.isDeprecated = true; field.deprecationReason = this.args.reason; } visitEnumValue(value) { value.isDeprecated = true; value.deprecationReason = this.args.reason; } } Once we’ve implemented the directive , we just need to add the directives as shown below: schema.js export default makeExecutableSchema({ typeDefs, resolvers, schemaDirectives: { dreprecated: DeprecatedDirective, }, ... }); 7.3 Challenges Create a directive @uppercase that can be assigned to fields. This directive will transform the value of the attribute into uppercase. The directive declaration will look lie this directive @uppercase on FIELD_DEFINITION Create a directive @multiply with an attribute factor. The directive declaration should look like this directive @multiply ( factor: Int! ) on FIELD_DEFINITION And when the directive is assigned to an field its value will be multiplied by the given factor. input CarRequest { km:Int! @multiply(factor:2) } "],
["challenges-solution.html", "Chapter 8 Challenges Solution", " Chapter 8 Challenges Solution This workshop follows a story, and you should not start a new chapter if you did not complete the purposed challenges in the previous chapters. The workshop is completely open source and elaborated with great dedication and effort. So if you are taken the workshop is due to you want to learn GraphQL. That’s why I invite you to try to solve all the purposed challenges by yourself. On the other hand, you could be stuck in one of the chapters. Just in that case, you could checkout the solutions for the challenges. GraphQL: Objects - branch: feature/objects GraphQL: Operations - branch: feature/operations GraphQL: Interfaces and unions - branch: feature/interfaces-unions GraphQL: Directives - branch: feature/directives Please if you have any doubt contact me at ivan.corrales.solera@gmail.com "],
["references.html", "References", " References Apollo GraphQL GraphQL Specification "]
]
